<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Heart in Rain of Love</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: black;
            overflow: hidden;
        }

        .rain {
            position: absolute;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            line-height: 1.2;
            text-align: center;
            animation: fall linear;
            user-select: none;
            pointer-events: none;
        }

        @keyframes fall {
            0% {
                transform: translateY(-100px);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh);
                opacity: 0;
            }
        }

        .box {
            width: 100%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #rotate-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0);
            color: white;
            font-size: 40px;
            font-family: Arial, sans-serif;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #rotate-warning .rotate-icon {
            width: 200px;
            height: 200px;
            margin-bottom: 20px;
            animation: rotateIcon 4s infinite ease-in-out;
            opacity: 0.8;
        }

        @keyframes rotateIcon {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(-90deg); }
        }

        @media screen and (orientation: portrait) {
            #rotate-warning { display: flex; }
        }

        @media screen and (orientation: landscape) {
            #rotate-warning { display: none; }
        }
    </style>
</head>

<body>
    <div class="box" id="heartBox">
        <canvas id="pinkboard"></canvas>
    </div>

    <div id="rotate-warning">
        <svg class="rotate-icon" viewBox="0 0 24 24" fill="white" xmlns="http://www.w3.org/2000/svg">
            <path d="M7 1H17C18.66 1 20 2.34 20 4V20C20 21.66 18.66 23 17 23H7C5.34 23 4 21.66 4 20V4C4 2.34 5.34 1 7 1Z" stroke="white" stroke-width="2" fill="none"/>
            <path d="M12 4V2M12 22V20M15.5 8L17.5 10L15.5 12" stroke="white" stroke-width="2" fill="none"/>
        </svg>
        <div>Vui lòng xoay ngang màn hình để xem</div>
    </div>

    <script>
        function createRain() {
            const rain = document.createElement('div');
            rain.classList.add('rain');
            rain.innerHTML = 'i<br>l<br>o<br>v<br>e<br>y<br>o<br>u';
            rain.style.left = Math.random() * window.innerWidth + 'px';
            const duration = Math.random() * 1.5 + 1.5;
            rain.style.animationDuration = duration + 's';
            document.body.appendChild(rain);
            setTimeout(() => rain.remove(), duration * 1000);
        }
        setInterval(createRain, 80);

        const settings = {
            particles: { length: 2000, duration: 2, velocity: 100, effect: -1.3, size: 13 },
        };

        class Point {
            constructor(x = 0, y = 0) {
                this.x = x; this.y = y;
            }
            clone() { return new Point(this.x, this.y); }
            length(length) {
                if (length === undefined) return Math.sqrt(this.x ** 2 + this.y ** 2);
                this.normalize();
                this.x *= length;
                this.y *= length;
                return this;
            }
            normalize() {
                const length = this.length();
                this.x /= length;
                this.y /= length;
                return this;
            }
        }

        class Particle {
            constructor() {
                this.position = new Point();
                this.velocity = new Point();
                this.acceleration = new Point();
                this.age = 0;
            }
            initialize(x, y, dx, dy) {
                this.position.x = x;
                this.position.y = y;
                this.velocity.x = dx;
                this.velocity.y = dy;
                this.acceleration.x = dx * settings.particles.effect;
                this.acceleration.y = dy * settings.particles.effect;
                this.age = 0;
            }
            update(deltaTime) {
                this.position.x += this.velocity.x * deltaTime;
                this.position.y += this.velocity.y * deltaTime;
                this.velocity.x += this.acceleration.x * deltaTime;
                this.velocity.y += this.acceleration.y * deltaTime;
                this.age += deltaTime;
            }
            draw(ctx, img) {
                function ease(t) { return (--t) * t * t + 1; }
                const size = img.width * ease(this.age / settings.particles.duration);
                ctx.globalAlpha = 1 - this.age / settings.particles.duration;
                ctx.drawImage(img, this.position.x - size / 2, this.position.y - size / 2, size, size);
            }
        }

        class ParticlePool {
            constructor(length) {
                this.particles = Array.from({ length }, () => new Particle());
                this.firstActive = 0;
                this.firstFree = 0;
                this.duration = settings.particles.duration;
            }
            add(x, y, dx, dy) {
                this.particles[this.firstFree].initialize(x, y, dx, dy);
                this.firstFree = (this.firstFree + 1) % this.particles.length;
                if (this.firstFree === this.firstActive)
                    this.firstActive = (this.firstActive + 1) % this.particles.length;
            }
            update(deltaTime) {
                let i = this.firstActive;
                while (i !== this.firstFree) {
                    this.particles[i].update(deltaTime);
                    if (this.particles[i].age >= this.duration)
                        this.firstActive = (this.firstActive + 1) % this.particles.length;
                    i = (i + 1) % this.particles.length;
                }
            }
            draw(ctx, img) {
                let i = this.firstActive;
                while (i !== this.firstFree) {
                    this.particles[i].draw(ctx, img);
                    i = (i + 1) % this.particles.length;
                }
            }
        }

        let heartStarted = false;
        function startHeartEffect() {
            if (heartStarted) return;
            heartStarted = true;

            document.getElementById('heartBox').style.display = 'flex';
            const canvas = document.getElementById('pinkboard');
            const ctx = canvas.getContext('2d');
            const particles = new ParticlePool(settings.particles.length);
            const rate = settings.particles.length / settings.particles.duration;
            let time;

            function pointOnHeart(t) {
                return new Point(
                    160 * Math.pow(Math.sin(t), 3),
                    130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
                );
            }

            const img = (() => {
                const c = document.createElement('canvas');
                const ctx2 = c.getContext('2d');
                c.width = settings.particles.size;
                c.height = settings.particles.size;
                ctx2.beginPath();
                let t = -Math.PI;
                let p = pointOnHeart(t);
                ctx2.moveTo(p.x + c.width / 2, c.height / 2 - p.y);
                while (t < Math.PI) {
                    t += 0.01;
                    p = pointOnHeart(t);
                    ctx2.lineTo(p.x + c.width / 2, c.height / 2 - p.y);
                }
                ctx2.closePath();
                ctx2.fillStyle = 'red';
                ctx2.fill();
                const image = new Image();
                image.src = c.toDataURL();
                return image;
            })();

            function render() {
                requestAnimationFrame(render);
                const newTime = Date.now() / 1000;
                const delta = newTime - (time || newTime);
                time = newTime;

                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const amount = rate * delta;
                for (let i = 0; i < amount; i++) {
                    const pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
                    const dir = pos.clone().length(settings.particles.velocity);
                    particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);
                }

                particles.update(delta);
                particles.draw(ctx, img);
            }

            render();
        }

        document.body.addEventListener('touchstart', startHeartEffect);
        document.body.addEventListener('mousedown', startHeartEffect);
    </script>
</body>

</html>
